searchNodes=[{"ref":"Calculator.html","title":"Calculator","type":"module","doc":"This module provides the necessary pieces to run the computation on the calls file. Some key choices are the use of Stream module to optmize memory usage and composability."},{"ref":"Calculator.html#compute/1","title":"Calculator.compute/1","type":"function","doc":"Runs the computation on a given file with its path."},{"ref":"Calculator.html#run/1","title":"Calculator.run/1","type":"function","doc":""},{"ref":"Calculator.Billage.html","title":"Calculator.Billage","type":"module","doc":"Module to calculate the time and billing for the calls."},{"ref":"Calculator.Billage.html#first/3","title":"Calculator.Billage.first/3","type":"function","doc":"Applies the business rules to calls in the initial portion of time. Based on the business rules, which implies that for an arbitrary initial period the billing is different, this function contains the rules for the initial period of each call. It is recursive on durations lower than the duration of the rule. And leaves after the minutes == factor is reached, leaving for the rules applied in Calculator.Billage.remainer/3. For example, for a 5 minute rule with 300 seconds duration. Examples iex&gt; Calculator.Billage.first({300, 5, 5}) {25, 0} iex&gt; Calculator.Billage.first({330, 5, 5}) {25, 30} # 30 seconds remaining"},{"ref":"Calculator.Billage.html#prepare/1","title":"Calculator.Billage.prepare/1","type":"function","doc":"Batches the stream into an enumerable to be further used."},{"ref":"Calculator.Billage.html#remainer/3","title":"Calculator.Billage.remainer/3","type":"function","doc":"Applies the business rules in the remainer time of the calls. For the ending period of the call, this function applies its rules and return the total value, it must be called after Calculator.Billage.first/3. Examples # 1. Receives 5 minutes and a accumulated 25 cents with a factor of 1 which means it applies 2 cents per minute # 2. Receives an extra 30 seconds iex&gt; Calculator.Billage.remainer({25, 300}, 1, 2) # 1. 35.0 iex&gt; Calculator.Billage.remainer({25, 330}, 1, 2) # 2. 36.0"},{"ref":"Calculator.Parser.html","title":"Calculator.Parser","type":"module","doc":"Parser for the time and other rules of the Calculator.Record"},{"ref":"Calculator.Record.html","title":"Calculator.Record","type":"module","doc":"Registries are parsed to a %Calculator.Record struct to further manipulation."},{"ref":"Calculator.Record.html#parse_record/1","title":"Calculator.Record.parse_record/1","type":"function","doc":"Parses a record to struct Examples iex&gt; Calculator.Record.parse_record(&quot;09:11:00;09:15:22;+351914374373;+351215355312&quot;) %Calculator.Record{ call_from: &quot;+351914374373&quot;, call_to: &quot;+351215355312&quot;, end_time: &quot;09:15:22&quot;, start_time: &quot;09:11:00&quot; }"},{"ref":"Calculator.Sanitizer.html","title":"Calculator.Sanitizer","type":"module","doc":"Sanitizes the Record with errors and invalid parameters. This could be highly improved with the use of Ecto and changesets. But for this specific use case this module can be easily modified and works well."},{"ref":"Calculator.Sanitizer.html#sanitize/1","title":"Calculator.Sanitizer.sanitize/1","type":"function","doc":"Sanitizes a record and returns the validation status. Examples iex&gt; record = %Calculator.Record{ ...&gt; call_from: &quot;+351914374373&quot;, ...&gt; call_to: &quot;+351963433432&quot;, ...&gt; end_time: &quot;17:49:30&quot;, ...&gt; start_time: &quot;17:44:04&quot; ...&gt; } iex&gt; Calculator.Sanitizer.sanitize(record) {:ok, %Calculator.Record{ call_from: &quot;+351914374373&quot;, call_to: &quot;+351963433432&quot;, end_time: &quot;17:49:30&quot;, start_time: &quot;17:44:04&quot; }} iex&gt; invalid_time = %Calculator.Record{ ...&gt; call_from: &quot;+351914374373&quot;, ...&gt; call_to: &quot;+351963433432&quot;, ...&gt; end_time: &quot;17:49:30&quot;, ...&gt; start_time: :error # Coming from the parsing functions ...&gt; } ...&gt; Calculator.Sanitizer.sanitize(invalid_time) {:error, %Calculator.Record{ call_from: &quot;+351914374373&quot;, call_to: &quot;+351963433432&quot;, end_time: &quot;17:49:30&quot;, start_time: :error }, &quot;INVALID TIME&quot;} iex&gt; invalid_phone = %Calculator.Record{ ...&gt; call_from: &quot;+35191437437a&quot;, # Mind the &quot;a&quot; at the end ...&gt; call_to: &quot;+35196343343&quot;, # Missing 1 number ...&gt; end_time: &quot;17:49:30&quot;, ...&gt; start_time: :error # Coming from the parsing functions ...&gt; } ...&gt; Calculator.Sanitizer.sanitize(invalid_phone) {:error, %Calculator.Record{ call_from: &quot;+35191437437a&quot;, # Mind the &quot;a&quot; at the end call_to: &quot;+35196343343&quot;, # Missing 1 number end_time: &quot;17:49:30&quot;, start_time: :error # Coming from the parsing functions }, &quot;INVALID PHONE&quot;}"}]